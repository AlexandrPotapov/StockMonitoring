//
//  StockInteractor.swift
//  StockMonitoring
//
//  Created by Александр on 30.03.2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol StockBusinessLogic
{
  func makeRequest(request: StockModel.Model.Request.RequestType)
}

protocol StockDataStore
{
  
  var stocks: [Stock] { get }
  var favouriteStocks: [Stock] { get set }
  var favouriteStocksCoreDataStore: FavouriteStocksCoreDataStore! { get  }
  var foundStocks: [Stock] { get }
  var indexPath: Int! { get }
}

class StockInteractor: StockBusinessLogic, StockDataStore
{
  var indexPath: Int!
  
  var favouriteStocksCoreDataStore: FavouriteStocksCoreDataStore!
  
  var stocks = [Stock]()
  var favouriteStocks = [Stock]()
  var foundSymbols = [String]()
  var foundStocks = [Stock]()
  
  var presenter: StockPresentationLogic?
  var worker: StockWorker?
  
  
  var searchProviders = Set<SearchProvider>()
  private var operationQueue = OperationQueue ()
  
  
  
  private var fetcher: DataFetcher = NetworkDataFetcher(networking: NetworkService())
  
  // MARK: Do something
  
  func makeRequest(request: StockModel.Model.Request.RequestType)
  {
    if worker == nil {
      worker = StockWorker()
      worker?.doSomeWork()
      
    }
    
    favouriteStocksCoreDataStore = FavouriteStocksCoreDataStore.instance
    
    switch request {
    
    case .getStocks(let requestNeedsCancell) :
      guard requestNeedsCancell == false else {
        operationQueue.cancelAllOperations()
        self.presenter?.presentData(response: .hideActivityIndicator)
        return
      }
      if stocks.isEmpty {
        let operation = GetStockOperation { (stocks) in
          guard let stocks = stocks else { return }
          self.stocks = stocks
          OperationQueue.main.addOperation {
            self.presenter?.presentData(response: .hideActivityIndicator)
            self.presenter?.presentData(response: .presentStocks(stocksResponse: self.stocks ))
          }
          if !self.favouriteStocks.isEmpty {
            for (i, value) in self.stocks.enumerated() {
              for (x, stock) in self.favouriteStocks.enumerated() {
                if stock.ticker == value.ticker {
                  self.stocks[i].isFavourite = true
                  self.favouriteStocks[x] = (self.stocks[i])
                }
              }
            }
            OperationQueue.main.addOperation {
              self.presenter?.presentData(response: .hideActivityIndicator)
              self.presenter?.presentData(response: .presentStocks(stocksResponse: self.stocks ))
            }
            
          } else {
            
            self.favouriteStocksCoreDataStore.fetchStocks { (stocks: () throws -> [Stock]) in
              do {
                self.favouriteStocks = try stocks()
                if !(self.favouriteStocks.isEmpty) {
                  for (i, value) in self.stocks.enumerated() {
                    for stock in self.favouriteStocks {
                      if stock.ticker == value.ticker {
                        self.stocks[i].isFavourite = true
                        self.favouriteStocksCoreDataStore.updateStock(stockToUpdate: (self.stocks[i]), completionHandler: {_ in
                        })
                        
                      }
                    }
                  }
                  
                  OperationQueue.main.addOperation {
                    self.presenter?.presentData(response: .hideActivityIndicator)
                    self.presenter?.presentData(response: .presentStocks(stocksResponse: self.stocks))
                  }
                } else {
                  OperationQueue.main.addOperation {
                    self.presenter?.presentData(response: .hideActivityIndicator)
                    self.presenter?.presentData(response: .presentStocks(stocksResponse: self.stocks))
                  }
                }
              } catch {}
            }
          }
        }
        
        
        operationQueue.addOperation(operation)
      } else {
        if !self.favouriteStocks.isEmpty {
          for (i, value) in self.stocks.enumerated() {
            self.stocks[i].isFavourite = false
            for stock in self.favouriteStocks {
              if stock.ticker == value.ticker {
                self.stocks[i].isFavourite = true
                
              }
            }
          }
          self.presenter?.presentData(response: .hideActivityIndicator)
          self.presenter?.presentData(response: .presentStocks(stocksResponse: self.stocks))
        } else {
          for (i, _) in self.stocks.enumerated() {
            self.stocks[i].isFavourite = false
          }
          self.presenter?.presentData(response: .hideActivityIndicator)
          self.presenter?.presentData(response: .presentStocks(stocksResponse: self.stocks))
        }
      }
      
      
    case .getFavouriteStocks:
      favouriteStocksCoreDataStore.fetchStocks { (stocks: () throws -> [Stock]) in
        do {
          self.favouriteStocks = try stocks()
          self.presenter?.presentData(response: .presentStocks(stocksResponse: self.favouriteStocks))
        } catch {}
      }
      
    case .getSearch(let request):
      for provider in searchProviders {
        provider.cancel()
      }
      searchProviders.removeAll()
      if request == "" {
        self.presenter?.presentData(response: .hideActivityIndicator)
      }
      self.presenter?.presentData(response: .presentStocks(stocksResponse: self.foundStocks ))
      
      guard request != "" else {
        if !self.favouriteStocks.isEmpty {
          for (i, value) in self.foundStocks.enumerated() {
            self.foundStocks[i].isFavourite = false
            for stock in self.favouriteStocks {
              if stock.ticker == value.ticker {
                self.foundStocks[i].isFavourite = true
              }
            }
          }
          self.presenter?.presentData(response: .presentStocks(stocksResponse: self.foundStocks ))
        } else {
          for i in self.foundStocks.indices {
            self.foundStocks[i].isFavourite = false
          }
          self.presenter?.presentData(response: .presentStocks(stocksResponse: self.foundStocks ))
        }
        self.presenter?.presentData(response: .presentStocks(stocksResponse: self.foundStocks ))
        return
      }
      
      let searchProvider = SearchProvider(request: request) { (foundStock) in
        guard let foundStocks = foundStock else { return }
        self.foundStocks = foundStocks
        if !self.favouriteStocks.isEmpty {
          for (i, value) in self.foundStocks.enumerated() {
            self.foundStocks[i].isFavourite = false
            for stock in self.favouriteStocks {
              if stock.ticker == value.ticker {
                self.foundStocks[i].isFavourite = true
                self.favouriteStocksCoreDataStore.updateStock(stockToUpdate: self.foundStocks[i]) { _ in
                }
              }
            }
          }
          OperationQueue.main.addOperation {
            self.presenter?.presentData(response: .hideActivityIndicator)
            self.presenter?.presentData(response: .presentStocks(stocksResponse: self.foundStocks ))
          }
        } else {
          OperationQueue.main.addOperation {
            self.presenter?.presentData(response: .hideActivityIndicator)
            self.presenter?.presentData(response: .presentStocks(stocksResponse: self.foundStocks ))
          }
        }
      }
      searchProviders.insert(searchProvider)
    }
  }
}
